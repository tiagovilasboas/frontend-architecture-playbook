# Front-End Architecture Playbook - Cursor Rules

## ğŸ¯ **Objetivo do Projeto**
Guia prÃ¡tico de arquiteturas front-end com tom de dev para dev, estilo Deschamps - direto, conversacional, sem enrolaÃ§Ã£o.

## ğŸ“ **Tom de Escrita**

### **Estilo Deschamps - Dev para Dev:**
- Linguagem direta e conversacional
- Evitar academicismo desnecessÃ¡rio
- Usar gÃ­rias de dev quando apropriado
- Focar em problemas reais, nÃ£o teÃ³ricos
- Explicar "por que" e "quando", nÃ£o sÃ³ "como"

### **Exemplos de Tom:**
âœ… **BOM:**
- "Se amanhÃ£ o React virar pÃ³, sua lÃ³gica de negÃ³cio tem que sobreviver"
- "BagunÃ§a total", "O inferno", "impossÃ­vel de testar"
- "NinguÃ©m enlouqueceu", "Menos bugs, mais paz"
- "Comece pequeno, evolua conforme necessÃ¡rio"

âŒ **RUIM:**
- "A implementaÃ§Ã£o de Clean Architecture proporciona..."
- "Ã‰ fundamental considerar os aspectos teÃ³ricos..."
- "A metodologia sugere uma abordagem sistemÃ¡tica..."

## ğŸ—ï¸ **Estrutura de ConteÃºdo**

### **Para cada arquitetura/padrÃ£o:**
1. **Hero Section** - TÃ­tulo + descriÃ§Ã£o direta
2. **O que Ã©?** - ExplicaÃ§Ã£o simples e prÃ¡tica
3. **Camadas/Conceitos** - ExplicaÃ§Ã£o visual com cÃ³digo
4. **Por que vale a pena?** - BenefÃ­cios prÃ¡ticos
5. **Quando usar?** - Casos reais de aplicaÃ§Ã£o
6. **Exemplos PrÃ¡ticos** - CÃ³digo real com cenÃ¡rios
7. **Armadilhas** - Problemas comuns e como evitar
8. **ReferÃªncias** - Livros, artigos, casos reais
9. **Resumo** - Pontos-chave

### **Exemplos Visuais:**
- Usar componentes Mantine (Paper, Card, Stack, etc.)
- Ãcones temÃ¡ticos do Tabler Icons
- CÃ³digo com syntax highlighting
- Alertas coloridos para dicas/avisos
- Badges para numeraÃ§Ã£o/classificaÃ§Ã£o

## ğŸ’» **Componentes Mantine**

### **Imports padrÃ£o:**
```typescript
import { Title, Text, Stack, Paper, Code, Alert, List, ThemeIcon, Group, Card, Badge } from '@mantine/core';
import { IconBulb, IconAlertTriangle, IconCheck, IconCode, IconStack } from '@tabler/icons-react';
```

### **Estrutura visual:**
- `Paper withBorder` para seÃ§Ãµes principais
- `Card withBorder` para itens menores
- `Stack gap="xl"` para espaÃ§amento
- `ThemeIcon` para Ã­cones temÃ¡ticos
- `Alert` para dicas importantes

## ğŸ¨ **Design System**

### **Cores temÃ¡ticas:**
- **Azul:** Conceitos principais, explicaÃ§Ãµes
- **Verde:** BenefÃ­cios, vantagens
- **Laranja:** Casos de uso, exemplos
- **Vermelho:** Problemas, armadilhas
- **Roxo:** Ferramentas, bibliotecas

### **Ãcones por seÃ§Ã£o:**
- **Hero:** IconCode, IconStack
- **BenefÃ­cios:** IconCheck, IconBulb
- **Problemas:** IconAlertTriangle
- **Exemplos:** IconCode
- **Armadilhas:** IconAlertTriangle
- **ReferÃªncias:** IconBulb

## ğŸ“š **ConteÃºdo TÃ©cnico**

### **Exemplos de cÃ³digo:**
- CÃ³digo real, nÃ£o pseudo-cÃ³digo
- CenÃ¡rios prÃ¡ticos (e-commerce, dashboard, etc.)
- Mostrar o "ruim" vs "bom"
- Incluir comentÃ¡rios explicativos
- Focar em problemas reais de dev

### **Casos de uso reais:**
- E-commerce (carrinho, checkout)
- Dashboard (mÃ©tricas, analytics)
- FormulÃ¡rios (validaÃ§Ã£o complexa)
- Apps mÃ³veis (estado, sincronizaÃ§Ã£o)
- Sistemas de design (componentes)

## ğŸš« **Armadilhas Comuns**

### **Sempre incluir:**
1. **Over-engineering** - AbstraÃ§Ãµes desnecessÃ¡rias
2. **DependÃªncias circulares** - Quebrar regras de dependÃªncia
3. **DomÃ­nio anÃªmico** - Entidades sem comportamento
4. **Testando tudo** - Overhead desnecessÃ¡rio
5. **AbstraÃ§Ã£o prematura** - YAGNI

### **Como apresentar:**
- **Problema:** DescriÃ§Ã£o direta do que dÃ¡ errado
- **Como evitar:** Dicas prÃ¡ticas e especÃ­ficas
- **Exemplo:** CÃ³digo mostrando ruim vs bom

## ğŸ“– **ReferÃªncias**

### **Incluir sempre:**
- **Livros:** Uncle Bob, Martin Fowler, Eric Evans
- **Artigos:** Links para blogs tÃ©cnicos
- **Casos reais:** Netflix, Spotify, Uber, Airbnb
- **Ferramentas:** TypeScript, Jest, bibliotecas relevantes

### **Tom das referÃªncias:**
- Focar em casos de sucesso reais
- Explicar o problema que resolveram
- Mostrar resultado prÃ¡tico
- Evitar referÃªncias acadÃªmicas excessivas

## ğŸ¯ **Foco por Arquitetura**

### **Clean Architecture:**
- IndependÃªncia de frameworks
- Testabilidade
- MigraÃ§Ãµes seguras
- SeparaÃ§Ã£o de responsabilidades

### **Component-Driven:**
- ReutilizaÃ§Ã£o
- ComposiÃ§Ã£o
- Design systems
- Manutenibilidade

### **Micro-frontends:**
- Escalabilidade de times
- IndependÃªncia de deploy
- Tecnologias heterogÃªneas
- IntegraÃ§Ã£o

### **Monorepo:**
- Compartilhamento de cÃ³digo
- Tooling centralizado
- RefatoraÃ§Ã£o segura
- Versionamento

## ğŸ”§ **ImplementaÃ§Ã£o TÃ©cnica**

### **Estrutura de arquivos:**
```
src/content/patterns/
â”œâ”€â”€ clean-architecture.tsx
â”œâ”€â”€ component-driven.tsx
â”œâ”€â”€ micro-frontends.tsx
â”œâ”€â”€ monorepo.tsx
â””â”€â”€ ...
```

### **Metadata padrÃ£o:**
```typescript
PatternName.metadata = {
  title: 'Nome da Arquitetura',
  description: 'DescriÃ§Ã£o direta e prÃ¡tica.'
};
```

## ğŸ¨ **Dark Theme - MANDATORY**

### **Mandatory Rules:**
- **ALL components MUST respect dark/light mode**
- **NEVER use fixed colors:** `background: 'white'`, `color: 'black'`, `#ffffff`, `#000000`
- **NEVER use gradients with fixed colors:** `linear-gradient(..., #f0f0f0, #ffffff)`
- **NEVER use light theme specific colors:** `var(--mantine-color-brand-0)`

### **Mandatory Patterns:**
- **ALWAYS use `withBorder`** in `Paper` and `Card` (automatic adaptation)
- **ALWAYS use `variant="light"`** for icons and badges
- **ALWAYS use `c="dimmed"`** for secondary text
- **ALWAYS let Mantine handle the theme** automatically

### **Mandatory Checklist Before Commit:**
- [ ] Tested in dark theme?
- [ ] Tested in light theme?
- [ ] No fixed colors used (white, black, #fff, etc)?
- [ ] Used `withBorder` instead of custom backgrounds?
- [ ] Used `variant="light"` for icons/badges?
- [ ] Used `c="dimmed"` for secondary text?

### **Safe Code Examples:**
```tsx
// âœ… ALWAYS USE
<Paper withBorder>
<Card withBorder>
<ThemeIcon variant="light">
<Text c="dimmed">
<Badge variant="light">
```

### **Dangerous Code Examples:**
```tsx
// âŒ NEVER USE
style={{ background: 'white' }}
style={{ color: 'black' }}
background: 'linear-gradient(..., #f0f0f0, #ffffff)'
style={{ background: 'var(--mantine-color-brand-0)' }}
```

### **Mandatory Testing:**
- **ALWAYS test both themes** before committing
- **ALWAYS check contrast** and readability
- **ALWAYS use theme toggle** to validate

### **ğŸ’¡ Practical Tips:**
- **Always test in dark mode** before committing
- Use `withBorder` instead of custom backgrounds
- Prefer `variant="light"` instead of fixed colors
- If you need gradient, use CSS theme variables
- `Paper` and `Card` already come with automatic adaptation

### **ğŸ¨ Practical Examples:**

#### âŒ **Bad Code:**
```tsx
<Paper style={{ background: 'linear-gradient(135deg, #f0f0f0, #ffffff)' }}>
  Content
</Paper>
```

#### âœ… **Good Code:**
```tsx
<Paper withBorder>
  Content
</Paper>
```

### **ğŸ” Complete Checklist Before Commit:**
- [ ] Tested in dark theme?
- [ ] Tested in light theme?
- [ ] No fixed colors used (white, black, #fff, etc)?
- [ ] Used `withBorder` instead of custom backgrounds?
- [ ] Used `variant="light"` for icons/badges?
- [ ] Used `c="dimmed"` for secondary text?

**Remember:** Mantine already handles theme adaptation automatically. Let it do the heavy lifting! ğŸš€

## ğŸ“ **Quality Checklist**

Before finalizing each file:
- [ ] Dev-to-dev tone consistent
- [ ] Practical and real examples
- [ ] Functional and testable code
- [ ] Pitfalls and how to avoid them
- [ ] References and real cases
- [ ] Responsive and accessible design
- [ ] **ALL components respect dark/light mode**
- [ ] **NO fixed colors used** (white, black, #fff, etc)
- [ ] **ALWAYS used `withBorder`** in Paper/Card
- [ ] **ALWAYS used `variant="light"`** for icons/badges
- [ ] **ALWAYS used `c="dimmed"`** for secondary text
- [ ] **Tested in BOTH themes** (dark/light)
- [ ] Consistent visual structure

## ğŸš€ **PrÃ³ximos Passos**

Para cada nova arquitetura:
1. Seguir a estrutura definida
2. Manter o tom Deschamps
3. Incluir exemplos visuais
4. Adicionar armadilhas especÃ­ficas
5. Referenciar casos reais
6. Testar no tema dark

---

**Lembre-se:** O objetivo Ã© criar um guia que devs realmente usem, nÃ£o um livro acadÃªmico. Foque em resolver problemas reais com linguagem direta e exemplos prÃ¡ticos. 