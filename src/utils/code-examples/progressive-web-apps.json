[
  {
    "id": "pwa-service-worker",
    "title": "Service Worker - Cache e Offline",
    "description": "Service worker que gerencia cache e funcionalidade offline",
    "content": "// public/sw.js\nconst CACHE_NAME = 'app-v1';\nconst urlsToCache = [\n  '/',\n  '/styles/main.css',\n  '/scripts/app.js',\n  '/images/logo.png'\n];\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(urlsToCache))\n  );\n});\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        if (response) {\n          return response;\n        }\n        return fetch(event.request);\n      })\n  );\n});\n\n// Cache primeiro, depois network\n// Funciona offline\n// Performance melhorada"
  },
  {
    "id": "pwa-manifest",
    "title": "Web App Manifest - Instala√ß√£o",
    "description": "Manifest que permite instalar o app como nativo",
    "content": "// public/manifest.json\n{\n  \"name\": \"Meu App PWA\",\n  \"short_name\": \"App\",\n  \"description\": \"Aplica√ß√£o web progressiva\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#000000\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n\n// Permite instalar\n// App nativo\n// √çcone na home"
  },
  {
    "id": "pwa-push-notifications",
    "title": "Push Notifications - Engajamento",
    "description": "Sistema de notifica√ß√µes push para manter usu√°rios engajados",
    "content": "// public/sw.js\nself.addEventListener('push', event => {\n  const options = {\n    body: event.data.text(),\n    icon: '/icons/icon-192x192.png',\n    badge: '/icons/badge-72x72.png',\n    vibrate: [100, 50, 100],\n    data: {\n      dateOfArrival: Date.now(),\n      primaryKey: 1\n    },\n    actions: [\n      {\n        action: 'explore',\n        title: 'Ver',\n        icon: '/icons/checkmark.png'\n      },\n      {\n        action: 'close',\n        title: 'Fechar',\n        icon: '/icons/xmark.png'\n      }\n    ]\n  };\n  \n  event.waitUntil(\n    self.registration.showNotification('Nova notifica√ß√£o', options)\n  );\n});\n\n// Notifica√ß√µes push\n// Engajamento maior\n// Usu√°rio volta mais"
  },
  {
    "id": "pwa-ecommerce-offline",
    "title": "E-commerce - Funciona Offline",
    "description": "E-commerce que funciona offline com cache de produtos e carrinho local",
    "content": "// ‚ùå RUIM - Site normal\n// Sem internet = site quebra\n// Usu√°rio perde carrinho\n// Experi√™ncia ruim\n\n// ‚úÖ BOM - PWA E-commerce\n// public/sw.js\nconst CACHE_NAME = 'ecommerce-v1';\nconst urlsToCache = [\n  '/',\n  '/products',\n  '/cart',\n  '/styles/main.css',\n  '/scripts/app.js',\n  '/api/products' // Cache produtos\n];\n\nself.addEventListener('fetch', event => {\n  if (event.request.url.includes('/api/')) {\n    // Cache API calls\n    event.respondWith(\n      caches.match(event.request)\n        .then(response => {\n          if (response) {\n            return response;\n          }\n          return fetch(event.request)\n            .then(response => {\n              const responseClone = response.clone();\n              caches.open(CACHE_NAME)\n                .then(cache => cache.put(event.request, responseClone));\n              return response;\n            });\n        })\n    );\n  }\n});\n\n// pages/products/[id].js\nexport default function ProductPage({ product }) {\n  const [isOffline, setIsOffline] = useState(false);\n  \n  useEffect(() => {\n    // Detecta status offline\n    const handleOnline = () => setIsOffline(false);\n    const handleOffline = () => setIsOffline(true);\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  \n  const addToCart = async () => {\n    try {\n      await addItemToCart(product.id);\n      showNotification('Produto adicionado!');\n    } catch (error) {\n      // Salva localmente se offline\n      saveToLocalCart(product);\n      showNotification('Salvo para adicionar quando online');\n    }\n  };\n  \n  return (\n    <div>\n      {isOffline && (\n        <Alert color=\"yellow\" title=\"Modo Offline\">\n          Algumas funcionalidades podem estar limitadas\n        </Alert>\n      )}\n      <h1>{product.name}</h1>\n      <p>{product.description}</p>\n      <button onClick={addToCart}>\n        Adicionar ao Carrinho\n      </button>\n    </div>\n  );\n}\n\n// Funciona offline\n// Cache produtos\n// Salva carrinho localmente\n// Sincroniza quando online"
  },
  {
    "id": "pwa-social-notifications",
    "title": "Social Media - Notifica√ß√µes Push",
    "description": "App social com notifica√ß√µes push para manter engajamento",
    "content": "// ‚ùå RUIM - Site normal\n// Sem notifica√ß√µes\n// Usu√°rio n√£o volta\n// Engagement baixo\n\n// ‚úÖ BOM - PWA Social\n// public/sw.js\nself.addEventListener('push', event => {\n  const options = {\n    body: event.data.text(),\n    icon: '/icons/icon-192x192.png',\n    badge: '/icons/badge-72x72.png',\n    vibrate: [100, 50, 100],\n    data: {\n      dateOfArrival: Date.now(),\n      primaryKey: 1\n    },\n    actions: [\n      {\n        action: 'explore',\n        title: 'Ver',\n        icon: '/icons/checkmark.png'\n      },\n      {\n        action: 'close',\n        title: 'Fechar',\n        icon: '/icons/xmark.png'\n      }\n    ]\n  };\n  \n  event.waitUntil(\n    self.registration.showNotification('Nova notifica√ß√£o', options)\n  );\n});\n\n// components/NotificationPermission.js\nfunction NotificationPermission() {\n  const [permission, setPermission] = useState('default');\n  \n  const requestPermission = async () => {\n    const result = await Notification.requestPermission();\n    setPermission(result);\n    \n    if (result === 'granted') {\n      // Registra service worker\n      const registration = await navigator.serviceWorker.register('/sw.js');\n      \n      // Inscreve para push notifications\n      const subscription = await registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: urlBase64ToUint8Array(process.env.VAPID_PUBLIC_KEY)\n      });\n      \n      // Envia subscription para servidor\n      await fetch('/api/push/subscribe', {\n        method: 'POST',\n        body: JSON.stringify(subscription),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    }\n  };\n  \n  return (\n    <div>\n      {permission === 'default' && (\n        <button onClick={requestPermission}>\n          Ativar Notifica√ß√µes\n        </button>\n      )}\n      {permission === 'granted' && (\n        <div>‚úÖ Notifica√ß√µes ativadas</div>\n      )}\n    </div>\n  );\n}\n\n// Notifica√ß√µes push\n// Engagement maior\n// Usu√°rio volta mais"
  },
  {
    "id": "pwa-pitfall-over-caching",
    "title": "üö´ Over-caching",
    "description": "Cachear tudo pode causar problemas de performance e espa√ßo",
    "content": "// ‚ùå RUIM - Cache tudo\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        if (response) {\n          return response; // Sempre retorna cache\n        }\n        return fetch(event.request);\n      })\n  );\n});\n\n// Problemas:\n// - Dados desatualizados\n// - Cache gigante\n// - Performance ruim\n// - Espa√ßo ocupado\n\n// ‚úÖ BOM - Cache seletivo\nself.addEventListener('fetch', event => {\n  // S√≥ cacheia recursos est√°ticos\n  if (event.request.url.includes('/static/')) {\n    event.respondWith(\n      caches.match(event.request)\n        .then(response => {\n          if (response) {\n            return response;\n          }\n          return fetch(event.request);\n        })\n    );\n  } else {\n    // API calls sempre fresh\n    event.respondWith(fetch(event.request));\n  }\n});\n\n// Cache seletivo\n// Dados sempre atualizados\n// Performance otimizada"
  },
  {
    "id": "pwa-pitfall-no-offline",
    "title": "üîÑ Sem Estrat√©gia Offline",
    "description": "PWA sem estrat√©gia offline clara pode confundir usu√°rios",
    "content": "// ‚ùå RUIM - Sem estrat√©gia offline\nfunction App() {\n  return (\n    <div>\n      <h1>Meu App</h1>\n      <button onClick={fetchData}>Carregar Dados</button>\n      {/* Sem feedback offline */}\n    </div>\n  );\n}\n\n// Problemas:\n// - Usu√°rio n√£o sabe se est√° offline\n// - Bot√µes que n√£o funcionam\n// - Experi√™ncia confusa\n\n// ‚úÖ BOM - Estrat√©gia offline clara\nfunction App() {\n  const [isOffline, setIsOffline] = useState(false);\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    const handleOnline = () => setIsOffline(false);\n    const handleOffline = () => setIsOffline(true);\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  \n  const fetchData = async () => {\n    try {\n      const response = await fetch('/api/data');\n      const result = await response.json();\n      setData(result);\n    } catch (error) {\n      // Carrega dados do cache se offline\n      const cachedData = await caches.match('/api/data');\n      if (cachedData) {\n        const result = await cachedData.json();\n        setData(result);\n      }\n    }\n  };\n  \n  return (\n    <div>\n      {isOffline && (\n        <Alert color=\"yellow\" title=\"Modo Offline\">\n          Algumas funcionalidades podem estar limitadas\n        </Alert>\n      )}\n      <h1>Meu App</h1>\n      <button onClick={fetchData} disabled={isOffline}>\n        {isOffline ? 'Dados Offline' : 'Carregar Dados'}\n      </button>\n      {data && <div>{/* Renderiza dados */}</div>}\n    </div>\n  );\n}\n\n// Feedback claro\n// Estrat√©gia offline\n// UX consistente"
  },
  {
    "id": "pwa-pitfall-bad-manifest",
    "title": "üì± Manifest Mal Configurado",
    "description": "Manifest mal configurado pode impedir instala√ß√£o ou causar problemas",
    "content": "// ‚ùå RUIM - Manifest b√°sico\n{\n  \"name\": \"App\",\n  \"start_url\": \"/\"\n}\n\n// Problemas:\n// - Sem √≠cones\n// - Nome gen√©rico\n// - Sem tema\n// - N√£o instala\n\n// ‚úÖ BOM - Manifest completo\n{\n  \"name\": \"Meu App PWA\",\n  \"short_name\": \"App\",\n  \"description\": \"Aplica√ß√£o web progressiva incr√≠vel\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#000000\",\n  \"orientation\": \"portrait\",\n  \"scope\": \"/\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-72x72.png\",\n      \"sizes\": \"72x72\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/icon-96x96.png\",\n      \"sizes\": \"96x96\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/icon-128x128.png\",\n      \"sizes\": \"128x128\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/icon-144x144.png\",\n      \"sizes\": \"144x144\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/icon-152x152.png\",\n      \"sizes\": \"152x152\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/icon-384x384.png\",\n      \"sizes\": \"384x384\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    }\n  ],\n  \"shortcuts\": [\n    {\n      \"name\": \"Home\",\n      \"short_name\": \"Home\",\n      \"description\": \"Ir para a p√°gina inicial\",\n      \"url\": \"/\",\n      \"icons\": [\n        {\n          \"src\": \"/icons/home-96x96.png\",\n          \"sizes\": \"96x96\"\n        }\n      ]\n    }\n  ]\n}\n\n// Manifest completo\n// √çcones em todos os tamanhos\n// Instala√ß√£o garantida\n// UX nativa"
  },
  {
    "id": "pwa-productivity-offline",
    "title": "üìù Productivity App - Offline Sync",
    "description": "App de produtividade que funciona offline com sincroniza√ß√£o autom√°tica",
    "content": "// ‚ùå RUIM - App normal\n// N√£o funciona offline\n// Dados perdidos\n// Sincroniza√ß√£o manual\n\n// ‚úÖ BOM - PWA Productivity\n// utils/offlineStorage.js\nclass OfflineStorage {\n  constructor() {\n    this.dbName = 'productivity-app';\n    this.version = 1;\n  }\n  \n  async init() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      \n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        // Store para todos\n        const todosStore = db.createObjectStore('todos', { keyPath: 'id' });\n        todosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n        \n        // Store para notes\n        const notesStore = db.createObjectStore('notes', { keyPath: 'id' });\n        notesStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n      };\n    });\n  }\n  \n  async saveTodo(todo) {\n    const db = await this.init();\n    const transaction = db.transaction(['todos'], 'readwrite');\n    const store = transaction.objectStore('todos');\n    \n    todo.syncStatus = 'pending';\n    await store.put(todo);\n  }\n  \n  async getTodos() {\n    const db = await this.init();\n    const transaction = db.transaction(['todos'], 'readonly');\n    const store = transaction.objectStore('todos');\n    \n    return store.getAll();\n  }\n}\n\n// components/TodoApp.js\nfunction TodoApp() {\n  const [todos, setTodos] = useState([]);\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const storage = new OfflineStorage();\n  \n  useEffect(() => {\n    loadTodos();\n    \n    const handleOnline = () => {\n      setIsOnline(true);\n      syncData();\n    };\n    \n    const handleOffline = () => {\n      setIsOnline(false);\n    };\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  \n  const loadTodos = async () => {\n    const localTodos = await storage.getTodos();\n    setTodos(localTodos);\n  };\n  \n  const addTodo = async (text) => {\n    const todo = {\n      id: Date.now(),\n      text,\n      completed: false,\n      createdAt: new Date().toISOString()\n    };\n    \n    await storage.saveTodo(todo);\n    setTodos(prev => [...prev, todo]);\n  };\n  \n  const syncData = async () => {\n    const pendingTodos = todos.filter(todo => todo.syncStatus === 'pending');\n    \n    for (const todo of pendingTodos) {\n      try {\n        await fetch('/api/todos', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(todo)\n        });\n        \n        // Marca como sincronizado\n        todo.syncStatus = 'synced';\n        await storage.saveTodo(todo);\n      } catch (error) {\n        console.error('Erro ao sincronizar:', error);\n      }\n    }\n  };\n  \n  return (\n    <div>\n      {!isOnline && (\n        <Alert color=\"yellow\" title=\"Modo Offline\">\n          Dados salvos localmente\n        </Alert>\n      )}\n      \n      <form onSubmit={(e) => {\n        e.preventDefault();\n        const text = e.target.todo.value;\n        addTodo(text);\n        e.target.todo.value = '';\n      }}>\n        <input name=\"todo\" placeholder=\"Nova tarefa...\" />\n        <button type=\"submit\">Adicionar</button>\n      </form>\n      \n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id)}\n            />\n            {todo.text}\n            {todo.syncStatus === 'pending' && ' ‚è≥'}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Funciona offline\n// Sincroniza√ß√£o autom√°tica\n// Dados nunca perdidos\n// Experi√™ncia fluida"
  },
  {
    "id": "pwa-pitfall-cache-strategy",
    "title": "üóÇÔ∏è Estrat√©gia de Cache",
    "description": "Cache desatualizado pode causar confus√£o e problemas de UX",
    "content": "// ‚ùå RUIM - Cache simples\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => response || fetch(event.request))\n  );\n});\n\n// Sempre retorna cache se dispon√≠vel\n// Dados desatualizados\n// UX confusa\n\n// ‚úÖ BOM - Cache inteligente\nself.addEventListener('fetch', event => {\n  // Recursos est√°ticos: cache-first\n  if (event.request.url.includes('/static/')) {\n    event.respondWith(\n      caches.match(event.request)\n        .then(response => response || fetch(event.request))\n    );\n  }\n  \n  // API calls: network-first\n  if (event.request.url.includes('/api/')) {\n    event.respondWith(\n      fetch(event.request)\n        .then(response => {\n          const responseClone = response.clone();\n          caches.open('api-cache')\n            .then(cache => cache.put(event.request, responseClone));\n          return response;\n        })\n        .catch(() => {\n          return caches.match(event.request);\n        })\n    );\n  }\n  \n  // HTML: stale-while-revalidate\n  if (event.request.destination === 'document') {\n    event.respondWith(\n      caches.match(event.request)\n        .then(cachedResponse => {\n          const fetchPromise = fetch(event.request)\n            .then(response => {\n              const responseClone = response.clone();\n              caches.open('html-cache')\n                .then(cache => cache.put(event.request, responseClone));\n              return response;\n            });\n          \n          return cachedResponse || fetchPromise;\n        })\n    );\n  }\n});\n\n// Cache inteligente\n// Dados sempre atualizados\n// Performance otimizada\n// UX consistente"
  },
  {
    "id": "pwa-pitfall-storage-limits",
    "title": "üíæ Limites de Storage",
    "description": "Cache muito grande pode encher o storage e quebrar o app",
    "content": "// ‚ùå RUIM - Cache infinito\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open('app-cache')\n      .then(cache => cache.addAll(urlsToCache))\n  );\n});\n\n// Cache cresce infinitamente\n// Storage pode encher\n\n// ‚úÖ BOM - Cache com limpeza\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames.map(cacheName => {\n          if (cacheName !== CACHE_NAME) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\n// Limpa caches antigos\n// Monitora uso de storage\nconst checkStorage = async () => {\n  if ('storage' in navigator && 'estimate' in navigator.storage) {\n    const estimate = await navigator.storage.estimate();\n    const usagePercent = (estimate.usage / estimate.quota) * 100;\n    \n    if (usagePercent > 80) {\n      // Limpa cache antigo\n      const cache = await caches.open(CACHE_NAME);\n      const keys = await cache.keys();\n      const oldKeys = keys.slice(0, Math.floor(keys.length / 2));\n      await Promise.all(oldKeys.map(key => cache.delete(key)));\n    }\n  }\n};\n\n// Storage controlado\n// App sempre funciona"
  },
  {
    "id": "pwa-pitfall-offline-ux",
    "title": "üì± UX Offline",
    "description": "Usu√°rio n√£o saber que est√° offline pode causar confus√£o",
    "content": "// ‚ùå RUIM - Sem indica√ß√£o offline\nfunction App() {\n  return (\n    <div>\n      <h1>Minha App</h1>\n      <button onClick={fetchData}>Carregar Dados</button>\n    </div>\n  );\n}\n\n// Usu√°rio n√£o sabe que est√° offline\n// Bot√£o quebra sem aviso\n\n// ‚úÖ BOM - UX offline clara\nfunction App() {\n  const [isOffline, setIsOffline] = useState(!navigator.onLine);\n  const [offlineData, setOfflineData] = useState([]);\n  \n  useEffect(() => {\n    const handleOnline = () => setIsOffline(false);\n    const handleOffline = () => setIsOffline(true);\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    // Carrega dados offline\n    loadOfflineData();\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  \n  const loadOfflineData = async () => {\n    const data = await getOfflineData();\n    setOfflineData(data);\n  };\n  \n  return (\n    <div>\n      {isOffline && (\n        <Alert color=\"yellow\" title=\"Modo Offline\" mb=\"md\">\n          Algumas funcionalidades podem estar limitadas. \n          Dados salvos localmente.\n        </Alert>\n      )}\n      \n      <h1>Minha App</h1>\n      \n      {isOffline ? (\n        <div>\n          <h2>Dados Offline</h2>\n          <ul>\n            {offlineData.map(item => (\n              <li key={item.id}>{item.name}</li>\n            ))}\n          </ul>\n          <p>Dados atualizados quando online</p>\n        </div>\n      ) : (\n        <button onClick={fetchData}>Carregar Dados</button>\n      )}\n    </div>\n  );\n}\n\n// Status offline claro\n// Funcionalidades dispon√≠veis\n// Experi√™ncia consistente"
  },
  {
    "id": "pwa-pitfall-push-notifications",
    "title": "üîî Notifica√ß√µes Push",
    "description": "Notifica√ß√µes irritantes podem fazer usu√°rio desinstalar o app",
    "content": "// ‚ùå RUIM - Notifica√ß√£o agressiva\n// Pede permiss√£o na primeira visita\n// Notifica√ß√µes irrelevantes\n// Usu√°rio desinstala\n\n// ‚úÖ BOM - Notifica√ß√µes inteligentes\nfunction NotificationManager() {\n  const [permission, setPermission] = useState('default');\n  \n  const requestPermission = async () => {\n    // S√≥ pede ap√≥s usu√°rio interagir\n    const result = await Notification.requestPermission();\n    setPermission(result);\n    \n    if (result === 'granted') {\n      // Salva prefer√™ncias\n      localStorage.setItem('notifications', 'enabled');\n      \n      // Registra para push\n      const registration = await navigator.serviceWorker.ready;\n      const subscription = await registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: VAPID_PUBLIC_KEY\n      });\n      \n      // Envia para servidor\n      await fetch('/api/push/subscribe', {\n        method: 'POST',\n        body: JSON.stringify(subscription)\n      });\n    }\n  };\n  \n  const showNotification = (title, options) => {\n    if (permission === 'granted') {\n      // Verifica se usu√°rio est√° ativo\n      if (!document.hasFocus()) {\n        new Notification(title, {\n          ...options,\n          requireInteraction: false,\n          silent: false\n        });\n      }\n    }\n  };\n  \n  return (\n    <div>\n      {permission === 'default' && (\n        <button onClick={requestPermission}>\n          Ativar Notifica√ß√µes\n        </button>\n      )}\n      {permission === 'granted' && (\n        <div>‚úÖ Notifica√ß√µes ativadas</div>\n      )}\n    </div>\n  );\n}\n\n// Permiss√£o no momento certo\n// Notifica√ß√µes relevantes\n// UX respeitosa"
  },
  {
    "id": "pwa-pitfall-performance",
    "title": "‚ö° Performance",
    "description": "Service worker pesado pode causar problemas de performance",
    "content": "// ‚ùå RUIM - Service worker pesado\n// Cache tudo\n// Service worker grande\n// Performance ruim\n\n// ‚úÖ BOM - Service worker otimizado\n// public/sw.js\nconst CACHE_NAME = 'app-v1';\nconst STATIC_CACHE = 'static-v1';\nconst DYNAMIC_CACHE = 'dynamic-v1';\n\n// Cache apenas recursos cr√≠ticos\nconst STATIC_URLS = [\n  '/',\n  '/styles/critical.css',\n  '/scripts/app.js'\n];\n\n// Cache din√¢mico limitado\nconst MAX_DYNAMIC_ITEMS = 50;\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => cache.addAll(STATIC_URLS))\n  );\n});\n\nself.addEventListener('fetch', event => {\n  if (event.request.url.includes('/api/')) {\n    // Network-first para APIs\n    event.respondWith(\n      fetch(event.request)\n        .then(response => {\n          const responseClone = response.clone();\n          caches.open(DYNAMIC_CACHE)\n            .then(cache => {\n              cache.put(event.request, responseClone);\n              // Limita cache din√¢mico\n              cache.keys().then(keys => {\n                if (keys.length > MAX_DYNAMIC_ITEMS) {\n                  cache.delete(keys[0]);\n                }\n              });\n            });\n          return response;\n        })\n        .catch(() => caches.match(event.request))\n    );\n  } else {\n    // Cache-first para recursos est√°ticos\n    event.respondWith(\n      caches.match(event.request)\n        .then(response => response || fetch(event.request))\n    );\n  }\n});\n\n// Cache otimizado\n// Performance melhor\n// Storage controlado"
  }
]
