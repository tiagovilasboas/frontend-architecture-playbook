[
  {
    "title": "Código Acoplado à API",
    "description": "Lógica de negócio misturada com chamadas diretas à API",
    "code": "// ❌ RUIM - Código acoplado à API\n\n// Lógica de negócio misturada com API\nconst getUserOrders = async (userId: string) => {\n  try {\n    // Chamada direta à API\n    const response = await fetch(`/api/users/${userId}/orders`);\n    const orders = await response.json();\n    \n    // Lógica de negócio misturada\n    const activeOrders = orders.filter(order => order.status === 'active');\n    const totalValue = activeOrders.reduce((sum, order) => sum + order.value, 0);\n    \n    return {\n      orders: activeOrders,\n      totalValue,\n      count: activeOrders.length\n    };\n  } catch (error) {\n    console.error('API Error:', error);\n    throw new Error('Failed to fetch orders');\n  }\n};\n\n// Componente que depende diretamente da API\nconst OrderList = ({ userId }: { userId: string }) => {\n  const [orders, setOrders] = useState(null);\n  \n  useEffect(() => {\n    getUserOrders(userId).then(setOrders);\n  }, [userId]);\n  \n  // ... resto do componente\n};"
  },
  {
    "title": "Repository Pattern",
    "description": "Abstração que separa acesso aos dados da lógica de negócio",
    "code": "// ✅ BOM - Repository Pattern\n\n// Interface do Repository\ninterface OrderRepository {\n  getUserOrders(userId: string): Promise<Order[]>;\n  createOrder(order: CreateOrder): Promise<Order>;\n  updateOrder(id: string, updates: Partial<Order>): Promise<Order>;\n}\n\n// Implementação para API\nclass ApiOrderRepository implements OrderRepository {\n  async getUserOrders(userId: string): Promise<Order[]> {\n    const response = await fetch(`/api/users/${userId}/orders`);\n    return response.json();\n  }\n  \n  async createOrder(order: CreateOrder): Promise<Order> {\n    const response = await fetch('/api/orders', {\n      method: 'POST',\n      body: JSON.stringify(order)\n    });\n    return response.json();\n  }\n  \n  async updateOrder(id: string, updates: Partial<Order>): Promise<Order> {\n    const response = await fetch(`/api/orders/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates)\n    });\n    return response.json();\n  }\n}\n\n// Lógica de negócio pura\nconst getUserActiveOrders = async (\n  userId: string, \n  orderRepo: OrderRepository\n) => {\n  const orders = await orderRepo.getUserOrders(userId);\n  const activeOrders = orders.filter(order => order.status === 'active');\n  const totalValue = activeOrders.reduce((sum, order) => sum + order.value, 0);\n  \n  return {\n    orders: activeOrders,\n    totalValue,\n    count: activeOrders.length\n  };\n};\n\n// Componente que usa o Repository\nconst OrderList = ({ userId }: { userId: string }) => {\n  const [orders, setOrders] = useState(null);\n  const orderRepo = new ApiOrderRepository();\n  \n  useEffect(() => {\n    getUserActiveOrders(userId, orderRepo).then(setOrders);\n  }, [userId]);\n  \n  // ... resto do componente\n};"
  },
  {
    "title": "Repository Complexo",
    "description": "Repository que faz mais do que deveria",
    "code": "// ❌ RUIM - Repository fazendo muito\n\nclass UserRepository {\n  async getUser(id: string) {\n    const response = await fetch(`/api/users/${id}`);\n    const user = await response.json();\n    \n    // Repository fazendo lógica de negócio\n    if (user.role === 'admin') {\n      user.permissions = ['read', 'write', 'delete'];\n    } else {\n      user.permissions = ['read'];\n    }\n    \n    // Repository fazendo validação\n    if (!user.email.includes('@')) {\n      throw new Error('Invalid email');\n    }\n    \n    // Repository fazendo transformação\n    user.fullName = `${user.firstName} ${user.lastName}`;\n    user.age = new Date().getFullYear() - user.birthYear;\n    \n    return user;\n  }\n}"
  },
  {
    "title": "Repository Simples",
    "description": "Repository focado apenas no acesso aos dados",
    "code": "// ✅ BOM - Repository simples\n\nclass UserRepository {\n  async getUser(id: string): Promise<User> {\n    const response = await fetch(`/api/users/${id}`);\n    return response.json();\n  }\n  \n  async createUser(user: CreateUser): Promise<User> {\n    const response = await fetch('/api/users', {\n      method: 'POST',\n      body: JSON.stringify(user)\n    });\n    return response.json();\n  }\n  \n  async updateUser(id: string, updates: Partial<User>): Promise<User> {\n    const response = await fetch(`/api/users/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates)\n    });\n    return response.json();\n  }\n}\n\n// Lógica de negócio separada\nconst getUserWithPermissions = async (userId: string, userRepo: UserRepository) => {\n  const user = await userRepo.getUser(userId);\n  \n  // Lógica de negócio aqui\n  const permissions = user.role === 'admin' \n    ? ['read', 'write', 'delete'] \n    : ['read'];\n  \n  return { ...user, permissions };\n};"
  }
] 