[
  {
    "id": "event-driven-emitter",
    "title": "useReducer + dispatch (React nativo)",
    "description": "Event-driven com o próprio React: ações como eventos",
    "file": "event-driven",
    "content": "// Ações são os \"eventos\" do seu app\ntype CartEvent =\n  | { type: 'ITEM_ADDED'; product: Product; qty: number }\n  | { type: 'ITEM_REMOVED'; productId: string }\n  | { type: 'CART_CLEARED' };\n\n// Reducer é o \"event handler\" central\nfunction cartReducer(state: CartState, event: CartEvent): CartState {\n  switch (event.type) {\n    case 'ITEM_ADDED':\n      return { ...state, items: [...state.items, { ...event.product, qty: event.qty }] };\n    case 'ITEM_REMOVED':\n      return { ...state, items: state.items.filter(i => i.id !== event.productId) };\n    case 'CART_CLEARED':\n      return { ...state, items: [] };\n  }\n}\n\n// Componente emite eventos via dispatch\nfunction AddToCartButton({ product }: { product: Product }) {\n  const dispatch = useCartDispatch(); // Context\n  return (\n    <button onClick={() => dispatch({ type: 'ITEM_ADDED', product, qty: 1 })}>\n      Adicionar\n    </button>\n  );\n}"
  },
  {
    "id": "event-driven-listener",
    "title": "Zustand com subscribe (side-effects reativos)",
    "description": "Reagir a mudanças de estado como eventos",
    "file": "event-driven",
    "content": "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nconst useCartStore = create(\n  subscribeWithSelector<CartState>((set) => ({\n    items: [],\n    addItem: (product: Product) =>\n      set((s) => ({ items: [...s.items, product] })),\n  }))\n);\n\n// Side-effects reativos - equivalente a \"listeners\"\n// Analytics reage automaticamente quando items muda\nuseCartStore.subscribe(\n  (state) => state.items,\n  (items, prevItems) => {\n    if (items.length > prevItems.length) {\n      const added = items[items.length - 1];\n      analytics.track('item_added', { product: added.id });\n    }\n  }\n);\n\n// Componente fica limpo - só lê estado\nfunction CartBadge() {\n  const count = useCartStore((s) => s.items.length);\n  return <Badge>{count}</Badge>;\n}"
  },
  {
    "id": "event-driven-bus",
    "title": "XState (state machine event-driven)",
    "description": "Máquina de estados para fluxos complexos",
    "file": "event-driven",
    "content": "import { createMachine, assign } from 'xstate';\nimport { useMachine } from '@xstate/react';\n\n// Eventos tipados definem o que pode acontecer\ntype CheckoutEvent =\n  | { type: 'NEXT' }\n  | { type: 'BACK' }\n  | { type: 'SUBMIT' }\n  | { type: 'PAYMENT_SUCCESS' }\n  | { type: 'PAYMENT_ERROR'; error: string };\n\nconst checkoutMachine = createMachine({\n  id: 'checkout',\n  initial: 'cart',\n  states: {\n    cart:     { on: { NEXT: 'shipping' } },\n    shipping: { on: { NEXT: 'payment', BACK: 'cart' } },\n    payment:  { on: {\n      SUBMIT: 'processing',\n      BACK: 'shipping'\n    }},\n    processing: { on: {\n      PAYMENT_SUCCESS: 'success',\n      PAYMENT_ERROR: 'payment'\n    }},\n    success: { type: 'final' }\n  }\n});\n\nfunction Checkout() {\n  const [state, send] = useMachine(checkoutMachine);\n  \n  // Cada evento é type-safe - impossível enviar evento inválido\n  return (\n    <div>\n      {state.matches('cart') && <Cart onNext={() => send({ type: 'NEXT' })} />}\n      {state.matches('shipping') && <Shipping onNext={() => send({ type: 'NEXT' })} />}\n      {state.matches('payment') && <Payment onSubmit={() => send({ type: 'SUBMIT' })} />}\n      {state.matches('processing') && <Spinner />}\n      {state.matches('success') && <ThankYou />}\n    </div>\n  );\n}"
  },
  {
    "id": "event-driven-ecommerce",
    "title": "Quando usar cada abordagem",
    "description": "Comparação prática das 3 abordagens",
    "file": "event-driven",
    "content": "// 1️⃣ useReducer + Context: estado local compartilhado\n// Bom para: formulários multi-step, modais, componentes compostos\n// Trade-off: re-renders em todos os consumers\n\n// 2️⃣ Zustand com subscribe: estado global + side-effects\n// Bom para: analytics, logging, sincronização cross-tab\n// Trade-off: lógica fica fora de componentes (mais difícil de testar)\n\n// 3️⃣ XState: fluxos complexos com estados definidos\n// Bom para: checkout, onboarding, wizards, player de mídia\n// Trade-off: curva de aprendizado, overhead para casos simples\n\n// ❌ EVITE: window.dispatchEvent + CustomEvent\n// Por quê?\n// - Bypassa o ciclo de renderização do React\n// - Zero type safety (payloads são `any`)\n// - Impossível rastrear no React DevTools\n// - Cria dependências invisíveis entre componentes\n// - Mais difícil de testar que hooks/state management\n\n// ✅ EXCEÇÕES onde CustomEvent faz sentido:\n// - Comunicação entre micro-frontends (frameworks diferentes)\n// - Integração com bibliotecas não-React (ex: mapa, player)\n// - Analytics cross-framework"
  },
  {
    "id": "event-driven-dashboard",
    "title": "Server-Sent Events + React Query",
    "description": "Real-time event-driven no frontend",
    "file": "event-driven",
    "content": "// Real-time com SSE (Server-Sent Events) + React Query\nimport { useQueryClient } from '@tanstack/react-query';\n\nfunction useRealtimeUpdates() {\n  const queryClient = useQueryClient();\n  \n  useEffect(() => {\n    const source = new EventSource('/api/events');\n    \n    source.addEventListener('order:updated', (event) => {\n      const data = JSON.parse(event.data);\n      // Invalida queries afetadas - UI atualiza automaticamente\n      queryClient.invalidateQueries({ queryKey: ['orders', data.id] });\n    });\n    \n    source.addEventListener('stock:changed', (event) => {\n      const data = JSON.parse(event.data);\n      queryClient.setQueryData(\n        ['products', data.productId],\n        (old: Product) => ({ ...old, stock: data.newStock })\n      );\n    });\n    \n    source.onerror = () => source.close();\n    return () => source.close();\n  }, [queryClient]);\n}\n\n// Componente usa dados normalmente - não sabe que são real-time\nfunction OrderStatus({ orderId }: { orderId: string }) {\n  const { data: order } = useQuery({\n    queryKey: ['orders', orderId],\n    queryFn: () => fetchOrder(orderId),\n  });\n  \n  return <Badge color={order?.status === 'delivered' ? 'green' : 'blue'}>\n    {order?.status}\n  </Badge>;\n}"
  }
]
